/**
 *
 * @author yutent<yutent.io@gmail.com>
 * @date 2020/10/29 16:48:26
 */

import { KEY_DICT, MULTI_KEYS, MULTI_KEY_CODES } from './key.dict.js'

var log = console.log

function bind(fn) {
  document.addEventListener('keydown', fn, false)
  return fn
}

function unbind(fn) {
  document.removeEventListener('keydown', fn, false)
}

export default class Keyboard {
  constructor() {
    this.__EVENTS__ = []
    this.__LAST__ = {}
    this.__TIME__ = 0

    this._keydown = bind(ev => {
      if (MULTI_KEY_CODES.includes(ev.keyCode)) {
        return
      }
      for (let k in this.__EVENTS__) {
        var item = this.__EVENTS__[k]
        var res = item.check(ev)

        if (res) {
          this.__LAST__[k]++
        } else {
          this.__LAST__[k] = -1
        }
        log('-------------------', res, this.__LAST__[k])

        if (this.__LAST__[k] + 1 === item.dict.length) {
          item.fn.forEach(function(fn) {
            fn(ev)
          })
          break
        }
      }
    })
  }

  destroy() {
    delete this.__EVENTS__
    unbind(this._keydown)
  }

  on(act, callback) {
    var key = []
    var dict = []
    var passed = true // 语法检测通过
    var _this = this

    act.forEach(it => {
      var tmp = []
      dict.push(tmp)
      it = it.split('+').map(k => {
        k = k.trim().toLowerCase()
        if (MULTI_KEYS[k]) {
          if (tmp.includes(k)) {
            passed = false
            console.error('功能键,同组中不能重复。⎣%s⎤', it)
          } else {
            tmp.push(k)
          }
        } else {
          if (tmp.key) {
            passed = false
            console.error('非功能键,同组不能出现多个。⎣%s⎤', it)
          } else {
            tmp.key = KEY_DICT[k]
          }
        }
        return k
      })
      key.push(it.join('+'))
    })

    if (passed) {
      key = key.join(',')
      this.__LAST__[key] = -1

      if (this.__EVENTS__[key]) {
        this.__EVENTS__[key].fn.push(callback)
      } else {
        this.__EVENTS__[key] = {
          key,
          dict,
          check(ev) {
            var now = Date.now()
            var idx = _this.__LAST__[this.key]
            var action = this.dict[idx + 1]
            var checked = false

            if (action) {
              checked = ev.keyCode === action.key

              if (idx > -1) {
                if (now - _this.__TIME__ > 100) {
                  checked = false
                }
              }
              if (checked) {
                for (let k of action) {
                  checked = ev[`${k}Key`]
                }
              }
              log(action, now, checked)
            }

            return checked
          },
          fn: [callback]
        }
      }
    }
  }
}
